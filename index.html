<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Processor</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            padding: 20px;
            color: #2d3748;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid #e2e8f0;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #48bb78;
        }

        .header h1 {
            color: #2d3748;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            color: #718096;
            font-size: 1.1em;
        }

        .loading-section {
            background: #e6fffa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #48bb78;
            text-align: center;
        }

        .loading-section.hidden {
            display: none;
        }

        .upload-section {
            background: #f7fafc;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #48bb78;
            text-align: center;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #38a169;
            background: #edf7ed;
        }

        .upload-section.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .file-input {
            display: none;
        }

        .upload-button, .process-button, .download-button {
            background: #48bb78;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .upload-button:hover, .process-button:hover:not(:disabled), .download-button:hover {
            background: #38a169;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
        }

        .settings-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .setting-group {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #48bb78;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2d3748;
        }

        .setting-group input, .setting-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s ease;
            background: white;
        }

        .setting-group input:focus, .setting-group select:focus {
            outline: none;
            border-color: #48bb78;
            box-shadow: 0 0 0 3px rgba(72, 187, 120, 0.1);
        }

        .process-button {
            width: 100%;
            padding: 18px;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .process-button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            background: #f7fafc;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 5px solid #48bb78;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #48bb78;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #718096;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .corrections-list {
            max-height: 300px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
        }

        .correction-item {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .correction-item:last-child {
            border-bottom: none;
        }

        .original-text {
            color: #e53e3e;
            text-decoration: line-through;
        }

        .corrected-text {
            color: #48bb78;
            font-weight: 600;
        }

        .download-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            width: 0%;
            transition: width 0.3s ease;
        }

        .quality-score {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            color: white;
            margin: 10px 0;
        }

        .score-excellent { background: #48bb78; }
        .score-good { background: #68d391; }
        .score-fair { background: #ed8936; }
        .score-poor { background: #e53e3e; }

        .hidden {
            display: none;
        }

        .spinner {
            border: 3px solid #e2e8f0;
            border-top: 3px solid #48bb78;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .download-section {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Document Processor</h1>
            <p>Professional document editing and quality analysis</p>
        </div>

        <div class="loading-section" id="loadingSection">
            <div class="spinner"></div>
            <h3>Loading Python Environment...</h3>
            <p>Please wait while we initialize the document processor (this may take a moment on first load)</p>
        </div>

        <div class="upload-section disabled" id="uploadSection">
            <h3>üìÅ Upload Document</h3>
            <p>Select a Word document (.docx) to process</p>
            <input type="file" id="fileInput" class="file-input" accept=".docx">
            <button class="upload-button" onclick="selectFile()">
                Choose Document
            </button>
            <div id="fileName" style="margin-top: 10px; font-weight: 600;"></div>
        </div>

        <div class="settings-panel">
            <div class="setting-group">
                <label for="targetWordCount">Target Word Count (optional)</label>
                <input type="number" id="targetWordCount" placeholder="e.g., 500">
            </div>
            
            <div class="setting-group">
                <label for="targetReadingLevel">Target Reading Level</label>
                <select id="targetReadingLevel">
                    <option value="6">Grade 6</option>
                    <option value="7">Grade 7</option>
                    <option value="8" selected>Grade 8</option>
                    <option value="9">Grade 9</option>
                    <option value="10">Grade 10</option>
                </select>
            </div>
            
            <div class="setting-group">
                <label for="keywords">Keywords (comma-separated)</label>
                <input type="text" id="keywords" placeholder="health care, wellness, benefits">
            </div>
            
            <div class="setting-group">
                <label for="reportFormat">Report Format</label>
                <select id="reportFormat">
                    <option value="web">Web Report Only</option>
                    <option value="download">Download Report</option>
                    <option value="both">Both Formats</option>
                </select>
            </div>
        </div>

        <button class="process-button" id="processButton" onclick="processDocument()" disabled>
            üöÄ Process Document
        </button>

        <div class="progress-bar hidden" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="results-section hidden" id="resultsSection">
            <h3>üìä Processing Results</h3>
            
            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalCorrections">0</div>
                    <div class="stat-label">Total Corrections</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="wordCount">0</div>
                    <div class="stat-label">Word Count</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="readingLevel">0</div>
                    <div class="stat-label">Reading Level</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="qualityScore">0</div>
                    <div class="stat-label">Quality Score</div>
                </div>
            </div>

            <div id="qualityScoreDisplay"></div>

            <h4>üîß Corrections Applied</h4>
            <div class="corrections-list" id="correctionsList"></div>

            <div class="download-section">
                <button class="download-button" onclick="downloadProcessedDocument()">
                    üìÑ Download Processed Document
                </button>
                <button class="download-button" onclick="downloadReport()">
                    üìä Download Analysis Report
                </button>
            </div>
        </div>
    </div>

    <script>
        let pyodide;
        let originalDocument = null;
        let analysisResults = null;

        // Initialize Pyodide and Python environment
        async function initializePython() {
            try {
                console.log('Loading Pyodide...');
                pyodide = await loadPyodide();
                
                console.log('Installing packages...');
                await pyodide.loadPackage(['micropip']);
                
                // Install python-docx and other dependencies
                await pyodide.runPython(`
                    import micropip
                    await micropip.install(['python-docx', 'lxml'])
                `);
                
                console.log('Loading Python libraries...');
                await pyodide.runPython(`
                    import micropip
                    import js
                    from js import console
                    from docx import Document
                    from docx.shared import RGBColor, Pt
                    from docx.enum.text import WD_COLOR_INDEX
                    import io
                    import base64
                `);

                // Load our document processing code
                await pyodide.runPython(`
import re
import json
from datetime import datetime
import math
from docx import Document
from docx.shared import RGBColor, Pt
from docx.enum.text import WD_COLOR_INDEX
import io
import base64

# Document editing rules (converted from your YAML)
EDITING_RULES = {
    'timeFormatting': [
        {
            'pattern': r'\\b(\\d{1,2}):00\\b',
            'replacement': r'\\1',
            'description': 'Remove unnecessary :00 minutes'
        },
        {
            'pattern': r'\\b(\\d{1,2}(?::\\d{2})?)\\s*([Aa]\\.?[Mm]\\.?)\\b',
            'replacement': r'\\1 am',
            'description': 'Convert AM variations to lowercase am'
        },
        {
            'pattern': r'\\b(\\d{1,2}(?::\\d{2})?)\\s*([Pp]\\.?[Mm]\\.?)\\b',
            'replacement': r'\\1 pm',
            'description': 'Convert PM variations to lowercase pm'
        },
        {
            'pattern': r'\\b(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm))\\s*[-‚Äì‚Äî]\\s*(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm))\\b',
            'replacement': r'\\1‚Äì\\2',
            'description': 'Use en dash with no spaces for time ranges'
        }
    ],
    
    'dateFormatting': [
        {
            'pattern': r'\\b(0?[1-9]|1[0-2])/(0?[1-9]|[12]\\d|3[01])/(\\d{4})\\b',
            'replacement': 'DATE_CONVERSION',
            'description': 'Convert MM/DD/YYYY to Month DD, YYYY format'
        },
        {
            'pattern': r'\\b(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(\\d{1,2})(st|nd|rd|th),?\\s+(\\d{4})\\b',
            'replacement': r'\\1 \\2, \\4',
            'description': 'Remove ordinal suffixes from dates'
        }
    ],
    
    'numberFormatting': [
        {
            'pattern': r'\\b(?<![\\d\\-/])(?<!January\\s)(?<!February\\s)(?<!March\\s)(?<!April\\s)(?<!May\\s)(?<!June\\s)(?<!July\\s)(?<!August\\s)(?<!September\\s)(?<!October\\s)(?<!November\\s)(?<!December\\s)([1-9])\\b(?!\\s*(?:[AaPp]\\.?[Mm]\\.?|am|pm|:\\d|%|\\.|,\\d{3}|-star|th|nd|rd|st)\\b)(?![\\d\\-/])',
            'replacement': 'NUMBER_WORD',
            'description': 'Spell out numbers 1-9'
        },
        {
            'pattern': r'\\b(?<!extension\\s)(?<!ext\\.\\s)(?<!\\d)(\\d{1,3})(\\d{3})\\b(?![\\d/])',
            'replacement': r'\\1,\\2',
            'description': 'Add commas to numbers 1,000+'
        }
    ],
    
    'terminology': [
        {
            'pattern': r'\\bhealth plans\\b',
            'replacement': 'Health Care plans',
            'description': 'Use full company name for plans'
        },
        {
            'pattern': r'\\bGia Portal\\b',
            'replacement': 'Gia',
            'description': 'Replace Gia Portal with just Gia'
        },
        {
            'pattern': r'\\b(?:the\\s+)?(?:your\\s+)?(?:member\\s+)?portal\\b(?!\\s*(?:employer|provider|broker))',
            'replacement': 'Gia',
            'description': 'Replace portal variations with Gia'
        },
        {
            'pattern': r'\\b(?:an?\\s+)?ID\\s+card\\b',
            'replacement': 'Member ID card',
            'description': 'Standardize ID card references'
        },
        {
            'pattern': r'\\b[Ee]xchanges?\\b',
            'replacement': 'Marketplace',
            'description': 'Use Marketplace instead of Exchanges'
        },
        {
            'pattern': r'\\bessential plan\\b',
            'replacement': 'Essential Plan',
            'description': 'Capitalize Essential Plan'
        },
        {
            'pattern': r'\\bstudent plan\\b',
            'replacement': 'Student Plan',
            'description': 'Capitalize Student Plan'
        }
    ],
    
    'healthcareCommunication': [
        {
            'pattern': r'\\btelehealth\\b',
            'replacement': 'virtual care',
            'description': 'Use virtual care for member communications'
        },
        {
            'pattern': r'\\btelemedicine\\b',
            'replacement': 'virtual care',
            'description': 'Use virtual care for member communications'
        },
        {
            'pattern': r'\\bPrimary Care Physician\\b',
            'replacement': 'Primary Care Provider',
            'description': 'Use Provider instead of Physician'
        },
        {
            'pattern': r'\\bgift cards\\b',
            'replacement': 'reward cards',
            'description': 'Use reward cards for programs'
        },
        {
            'pattern': r'\\bWell-Being Rewards\\b',
            'replacement': 'WellBeing Rewards',
            'description': 'Keep WellBeing as one word for this program'
        },
        {
            'pattern': r'\\b[Ww]ell[Bb]eing\\b(?!\\s+Rewards)',
            'replacement': 'well-being',
            'description': 'Hyphenate well-being except for WellBeing Rewards'
        },
        {
            'pattern': r'\\bstar rating\\b',
            'replacement': 'Star Rating',
            'description': 'Capitalize Star Rating'
        },
        {
            'pattern': r'\\bNew York(?!\\s+State)\\b',
            'replacement': 'New York State',
            'description': 'Always include State for New York'
        }
    ],
    
    'corporateTerminology': [
        {
            'pattern': r'\\b(web site|web-site)\\b',
            'replacement': 'website',
            'description': 'Standardize website terminology'
        },
        {
            'pattern': r'\\b(e-mail|E-mail)\\b',
            'replacement': 'email',
            'description': 'Standardize email terminology'
        },
        {
            'pattern': r'\\blog in\\b(?!\\s+to)',
            'replacement': 'sign in',
            'description': 'Replace log in with sign in'
        },
        {
            'pattern': r'\\blog into\\b',
            'replacement': 'sign into',
            'description': 'Replace log into with sign into'
        },
        {
            'pattern': r'\\bhealthcare\\b',
            'replacement': 'health care',
            'description': 'Always use health care (two words)'
        },
        {
            'pattern': r'\\blogin\\b',
            'replacement': 'sign in',
            'description': 'Replace login with sign in'
        },
        {
            'pattern': r'\\bliving well\\b',
            'replacement': 'Living Well',
            'description': 'Living Well should be in title case'
        },
        {
            'pattern': r'\\blivingwell\\b',
            'replacement': 'Living Well',
            'description': 'Replace livingwell with Living Well'
        },
        {
            'pattern': r'\\bwellbeing rewards\\b',
            'replacement': 'WellBeing Rewards',
            'description': 'Standardize WellBeing Rewards brand'
        },
        {
            'pattern': r'\\bbe well rewards\\b',
            'replacement': 'Be Well Rewards',
            'description': 'Be Well Rewards should be in title case'
        },
        {
            'pattern': r'\\bsilver sneakers\\b',
            'replacement': 'Silver Sneakers',
            'description': 'Silver Sneakers should be in title case'
        },
        {
            'pattern': r'\\bexplanations? of benefits\\b',
            'replacement': 'Explanation of Benefits',
            'description': 'Explanation of Benefits should be in title case'
        },
        {
            'pattern': r'\\bpreventative\\b',
            'replacement': 'preventive',
            'description': 'Use preventive instead of preventative'
        }
    ],
    
    'stateAbbreviations': [
        {
            'pattern': r'\\b([NnVvCc])\\.([YyTt])\\.\\b',
            'replacement': 'STATE_ABBREV',
            'description': 'Remove periods from state abbreviations'
        },
        {
            'pattern': r'\\b(ny|vt|ct)\\b',
            'replacement': 'UPPERCASE_STATE',
            'description': 'Capitalize state abbreviations'
        }
    ],
    
    'prohibitedPhrases': [
        {
            'pattern': r'\\bin order to\\b',
            'replacement': 'to',
            'description': 'Remove redundant "in order" before "to"'
        },
        {
            'pattern': r'\\bat this point in time\\b',
            'replacement': 'now',
            'description': 'Replace wordy time expressions'
        },
        {
            'pattern': r'\\b(quite|rather|somewhat|fairly)\\s+(good|bad|important|significant)\\b',
            'replacement': r'\\2',
            'description': 'Remove weak qualifying adverbs'
        },
        {
            'pattern': r'\\s&\\s',
            'replacement': ' and ',
            'description': 'Replace ampersands with "and"'
        }
    ],
    
    'punctuation': [
        {
            'pattern': r'  +',
            'replacement': ' ',
            'description': 'Remove multiple spaces'
        },
        {
            'pattern': r'\\.{3,}',
            'replacement': '‚Ä¶',
            'description': 'Use proper ellipsis character'
        }
    ]
}

def apply_editing_rules(text):
    """Apply all editing rules to text"""
    corrections = []
    total_corrections = 0
    corrections_by_category = {}
    
    for category_name, rules in EDITING_RULES.items():
        for rule in rules:
            pattern = rule['pattern']
            replacement = rule['replacement']
            description = rule['description']
            
            # Count matches before replacement
            matches = list(re.finditer(pattern, text, re.IGNORECASE))
            
            if matches:
                # Handle special replacements
                if replacement == 'DATE_CONVERSION':
                    def date_replace(match):
                        month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                                     'July', 'August', 'September', 'October', 'November', 'December']
                        month_num = int(match.group(1))
                        day = int(match.group(2))
                        year = match.group(3)
                        return f"{month_names[month_num]} {day}, {year}"
                    
                    new_text = re.sub(pattern, date_replace, text, flags=re.IGNORECASE)
                
                elif replacement == 'NUMBER_WORD':
                    def number_replace(match):
                        number_words = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
                        num = int(match.group(1))
                        return number_words[num]
                    
                    new_text = re.sub(pattern, number_replace, text, flags=re.IGNORECASE)
                
                elif replacement == 'STATE_ABBREV':
                    def state_replace(match):
                        return match.group(1).upper() + match.group(2).upper()
                    
                    new_text = re.sub(pattern, state_replace, text, flags=re.IGNORECASE)
                
                elif replacement == 'UPPERCASE_STATE':
                    new_text = re.sub(pattern, lambda m: m.group(0).upper(), text, flags=re.IGNORECASE)
                
                else:
                    # Regular replacement
                    new_text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
                
                # Track corrections
                if new_text != text:
                    match_count = len(matches)
                    total_corrections += match_count
                    corrections_by_category[category_name] = corrections_by_category.get(category_name, 0) + match_count
                    
                    for match in matches:
                        corrections.append({
                            'category': category_name,
                            'rule': description,
                            'original': match.group(0),
                            'replacement': 'Applied' if len(match.group(0)) > 50 else 'See pattern'
                        })
                    
                    text = new_text
    
    return {
        'processedText': text,
        'corrections': corrections,
        'totalCorrections': total_corrections,
        'correctionsByCategory': corrections_by_category
    }

def calculate_document_stats(text):
    """Calculate document statistics"""
    words = text.split()
    sentences = re.split(r'[.!?]+', text)
    sentences = [s.strip() for s in sentences if s.strip()]
    paragraphs = text.split('\\n\\n')
    paragraphs = [p.strip() for p in paragraphs if p.strip()]
    
    # Simple reading level calculation (Flesch-Kincaid approximation)
    if sentences:
        avg_words_per_sentence = len(words) / len(sentences)
    else:
        avg_words_per_sentence = 0
    
    # Simple syllable counting
    def count_syllables(word):
        word = word.lower()
        if len(word) <= 3:
            return 1
        word = re.sub(r'(?:[^laeiouy]es|ed|[^laeiouy]e)$', '', word)
        word = re.sub(r'^y', '', word)
        matches = re.findall(r'[aeiouy]{1,2}', word)
        return max(1, len(matches))
    
    if words:
        avg_syllables_per_word = sum(count_syllables(word) for word in words) / len(words)
    else:
        avg_syllables_per_word = 0
    
    reading_level = max(0, 0.39 * avg_words_per_sentence + 11.8 * avg_syllables_per_word - 15.59)
    
    return {
        'wordCount': len(words),
        'sentenceCount': len(sentences),
        'paragraphCount': len(paragraphs),
        'readingLevel': round(reading_level, 1),
        'avgWordsPerSentence': round(avg_words_per_sentence, 1),
        'avgSyllablesPerWord': round(avg_syllables_per_word, 1)
    }

def calculate_quality_score(stats, total_corrections, target_word_count=None, target_reading_level=8):
    """Calculate quality score"""
    score = 100
    
    # Deduct points for issues
    if target_word_count:
        word_diff = abs(stats['wordCount'] - target_word_count)
        percent_diff = word_diff / target_word_count
        if percent_diff > 0.2:
            score -= 10
        elif percent_diff > 0.1:
            score -= 5
    
    level_diff = abs(stats['readingLevel'] - target_reading_level)
    if level_diff > 2:
        score -= 15
    elif level_diff > 1:
        score -= 5
    
    if stats['avgWordsPerSentence'] > 25:
        score -= 10
    elif stats['avgWordsPerSentence'] > 20:
        score -= 5
    
    # Add points for corrections (shows improvement)
    if total_corrections > 50:
        score += 5
    elif total_corrections > 20:
        score += 3
    elif total_corrections > 10:
        score += 1
    
    return max(60, min(100, round(score)))

# Function to process document (will be called from JavaScript)
def process_document_text(text, target_word_count=None, target_reading_level=8):
    """Main processing function for plain text"""
    try:
        # Apply editing rules
        corrections_result = apply_editing_rules(text)
        
        # Calculate statistics
        stats = calculate_document_stats(corrections_result['processedText'])
        
        # Calculate quality score
        quality_score = calculate_quality_score(stats, corrections_result['totalCorrections'], target_word_count, target_reading_level)
        
        return {
            'processedText': corrections_result['processedText'],
            'corrections': corrections_result['corrections'],
            'totalCorrections': corrections_result['totalCorrections'],
            'correctionsByCategory': corrections_result['correctionsByCategory'],
            'statistics': stats,
            'qualityScore': quality_score
        }
    except Exception as e:
        console.log(f"Error in process_document_text: {str(e)}")
        return {'error': str(e)}

def process_docx_document(docx_bytes, target_word_count=None, target_reading_level=8):
    """Process a real DOCX document"""
    try:
        # Load the document from bytes
        doc_stream = io.BytesIO(docx_bytes)
        doc = Document(doc_stream)
        
        # Extract text from all paragraphs
        full_text = ""
        paragraph_texts = []
        
        for paragraph in doc.paragraphs:
            para_text = paragraph.text
            if para_text.strip():
                paragraph_texts.append(para_text)
                full_text += para_text + "\\n"
        
        console.log(f"Extracted {len(paragraph_texts)} paragraphs from DOCX")
        
        # Apply editing rules to the full text
        corrections_result = apply_editing_rules(full_text)
        
        # Calculate statistics
        stats = calculate_document_stats(corrections_result['processedText'])
        
        # Calculate quality score  
        quality_score = calculate_quality_score(stats, corrections_result['totalCorrections'], target_word_count, target_reading_level)
        
        # Create a new document with the processed content
        processed_doc = Document()
        
        # Add a header with processing info
        header_para = processed_doc.add_paragraph()
        header_run = header_para.add_run("PROCESSED DOCUMENT")
        header_run.bold = True
        header_run.font.size = Pt(16)
        header_run.font.color.rgb = RGBColor(72, 187, 120)  # Green color
        
        # Add processing details
        info_para = processed_doc.add_paragraph()
        info_para.add_run(f"Processed: {datetime.now().strftime('%B %d, %Y at %I:%M %p')}\\n")
        info_para.add_run(f"Quality Score: {quality_score}/100\\n")
        info_para.add_run(f"Total Corrections: {corrections_result['totalCorrections']}\\n")
        info_para.add_run(f"Word Count: {stats['wordCount']:,}\\n")
        info_para.add_run(f"Reading Level: Grade {stats['readingLevel']}")
        
        # Add separator
        processed_doc.add_paragraph("=" * 50)
        
        # Add the processed content as paragraphs
        processed_paragraphs = corrections_result['processedText'].split('\\n')
        
        for para_text in processed_paragraphs:
            if para_text.strip():
                processed_doc.add_paragraph(para_text.strip())
        
        # Save the processed document to bytes
        output_stream = io.BytesIO()
        processed_doc.save(output_stream)
        output_bytes = output_stream.getvalue()
        
        # Convert to base64 for JavaScript
        processed_docx_base64 = base64.b64encode(output_bytes).decode('utf-8')
        
        return {
            'processedText': corrections_result['processedText'],
            'corrections': corrections_result['corrections'],
            'totalCorrections': corrections_result['totalCorrections'],
            'correctionsByCategory': corrections_result['correctionsByCategory'],
            'statistics': stats,
            'qualityScore': quality_score,
            'processedDocxBase64': processed_docx_base64,
            'extractedParagraphs': len(paragraph_texts)
        }
        
    except Exception as e:
        console.log(f"Error in process_docx_document: {str(e)}")
        return {'error': str(e)}

def create_analysis_report_docx(analysis_results, original_filename, target_word_count=None, target_reading_level=8):
    """Create a professional analysis report as a DOCX document"""
    try:
        doc = Document()
        
        # Title
        title_para = doc.add_paragraph()
        title_run = title_para.add_run("DOCUMENT PROCESSING REPORT")
        title_run.bold = True
        title_run.font.size = Pt(18)
        title_run.font.color.rgb = RGBColor(72, 187, 120)
        title_para.alignment = 1  # Center alignment
        
        # Subtitle
        subtitle_para = doc.add_paragraph()
        subtitle_run = subtitle_para.add_run("Professional Document Analysis")
        subtitle_run.italic = True
        subtitle_run.font.size = Pt(12)
        subtitle_para.alignment = 1
        
        doc.add_paragraph()  # Spacing
        
        # Document info
        info_para = doc.add_paragraph()
        info_para.add_run("Document: ").bold = True
        info_para.add_run(original_filename)
        
        date_para = doc.add_paragraph()
        date_para.add_run("Generated: ").bold = True
        date_para.add_run(datetime.now().strftime('%B %d, %Y at %I:%M %p'))
        
        # Executive Summary
        doc.add_paragraph()
        summary_heading = doc.add_paragraph()
        summary_run = summary_heading.add_run("EXECUTIVE SUMMARY")
        summary_run.bold = True
        summary_run.font.size = Pt(14)
        summary_run.font.color.rgb = RGBColor(72, 187, 120)
        
        # Quality score
        quality_para = doc.add_paragraph()
        quality_para.add_run("Quality Score: ").bold = True
        score_run = quality_para.add_run(f"{analysis_results['qualityScore']}/100")
        score_run.bold = True
        
        # Key metrics
        metrics_para = doc.add_paragraph()
        metrics_text = (f"‚Ä¢ Total Corrections: {analysis_results['totalCorrections']}\\n"
                       f"‚Ä¢ Word Count: {analysis_results['statistics']['wordCount']:,}\\n"
                       f"‚Ä¢ Reading Level: Grade {analysis_results['statistics']['readingLevel']}\\n"
                       f"‚Ä¢ Sentences: {analysis_results['statistics']['sentenceCount']}\\n"
                       f"‚Ä¢ Paragraphs: {analysis_results['statistics']['paragraphCount']}")
        metrics_para.add_run(metrics_text)
        
        # Target Analysis
        if target_word_count or target_reading_level:
            doc.add_paragraph()
            target_heading = doc.add_paragraph()
            target_run = target_heading.add_run("TARGET ANALYSIS")
            target_run.bold = True
            target_run.font.size = Pt(14)
            target_run.font.color.rgb = RGBColor(72, 187, 120)
            
            if target_word_count:
                word_para = doc.add_paragraph()
                word_para.add_run("Word Count Target: ").bold = True
                actual_words = analysis_results['statistics']['wordCount']
                difference = actual_words - target_word_count
                percentage = (actual_words / target_word_count) * 100
                
                status = "‚úì On Target" if abs(difference) <= (target_word_count * 0.1) else (
                    f"‚ö† Over by {difference:,} words" if difference > 0 else 
                    f"‚ö† Under by {abs(difference):,} words"
                )
                word_para.add_run(f"{actual_words:,} words (target: {target_word_count:,}) {status}")
            
            if target_reading_level:
                level_para = doc.add_paragraph()
                level_para.add_run("Reading Level Target: ").bold = True
                actual_level = analysis_results['statistics']['readingLevel']
                level_diff = actual_level - target_reading_level
                
                status = "‚úì Appropriate Level" if abs(level_diff) <= 1.0 else f"‚ö† Difference: {level_diff:+.1f} grades"
                level_para.add_run(f"Grade {actual_level} (target: Grade {target_reading_level}) {status}")
        
        # Corrections Applied
        doc.add_paragraph()
        corrections_heading = doc.add_paragraph()
        corrections_run = corrections_heading.add_run("EDITING STANDARDS APPLIED")
        corrections_run.bold = True
        corrections_run.font.size = Pt(14)
        corrections_run.font.color.rgb = RGBColor(72, 187, 120)
        
        total_para = doc.add_paragraph()
        total_para.add_run("Total Corrections: ").bold = True
        total_para.add_run(f"{analysis_results['totalCorrections']} professional standards applied")
        
        # Corrections by category
        if analysis_results['correctionsByCategory']:
            cat_para = doc.add_paragraph()
            cat_para.add_run("Corrections by Category:").bold = True
            
            for category, count in sorted(analysis_results['correctionsByCategory'].items(), 
                                        key=lambda x: x[1], reverse=True):
                if count > 0:
                    category_name = category.replace('_', ' ').title()
                    cat_detail = doc.add_paragraph()
                    cat_detail.add_run(f"‚Ä¢ {category_name}: ").bold = True
                    cat_detail.add_run(f"{count} corrections")
        
        # Sample corrections
        if analysis_results['corrections']:
            doc.add_paragraph()
            sample_para = doc.add_paragraph()
            sample_para.add_run("Sample Corrections Applied:").bold = True
            
            for i, correction in enumerate(analysis_results['corrections'][:5], 1):
                corr_para = doc.add_paragraph()
                corr_para.add_run(f"{i}. {correction['rule']}").bold = True
                
                detail_para = doc.add_paragraph()
                detail_para.add_run(f"   \"{correction['original']}\" ‚Üí \"{correction['replacement']}\"")
                detail_para.runs[0].font.color.rgb = RGBColor(108, 117, 125)  # Gray color
            
            if len(analysis_results['corrections']) > 5:
                more_para = doc.add_paragraph()
                remaining = len(analysis_results['corrections']) - 5
                more_run = more_para.add_run(f"... and {remaining} more corrections")
                more_run.italic = True
        
        # Recommendations
        doc.add_paragraph()
        rec_heading = doc.add_paragraph()
        rec_run = rec_heading.add_run("RECOMMENDATIONS")
        rec_run.bold = True
        rec_run.font.size = Pt(14)
        rec_run.font.color.rgb = RGBColor(72, 187, 120)
        
        recommendations = []
        if analysis_results['qualityScore'] >= 90:
            recommendations.append("Excellent quality - document meets all professional standards")
        elif analysis_results['qualityScore'] >= 75:
            recommendations.append("Good quality - minor improvements may be beneficial")
        else:
            recommendations.append("Consider additional review for quality improvements")
        
        if analysis_results['totalCorrections'] > 50:
            recommendations.append(f"Applied {analysis_results['totalCorrections']} professional editing standards - document now compliant")
        elif analysis_results['totalCorrections'] > 0:
            recommendations.append(f"Applied {analysis_results['totalCorrections']} corrections to improve compliance")
        else:
            recommendations.append("Document already met professional editing standards")
        
        for i, rec in enumerate(recommendations, 1):
            rec_para = doc.add_paragraph()
            rec_para.add_run(f"{i}. ").bold = True
            rec_para.add_run(rec)
        
        # Footer
        doc.add_paragraph()
        footer_para = doc.add_paragraph()
        footer_para.add_run("Generated by Document Processor (Python-Powered)")
        footer_para.runs[0].italic = True
        footer_para.runs[0].font.size = Pt(10)
        footer_para.alignment = 1  # Center alignment
        
        # Save to bytes
        output_stream = io.BytesIO()
        doc.save(output_stream)
        output_bytes = output_stream.getvalue()
        
        # Convert to base64
        report_docx_base64 = base64.b64encode(output_bytes).decode('utf-8')
        
        return report_docx_base64
        
    except Exception as e:
        console.log(f"Error creating analysis report: {str(e)}")
        return None

console.log("Python document processor loaded successfully!")
                `);

                console.log('Python environment ready!');
                
                // Enable the interface
                document.getElementById('loadingSection').classList.add('hidden');
                document.getElementById('uploadSection').classList.remove('disabled');
                document.getElementById('processButton').disabled = false;
                
            } catch (error) {
                console.error('Error initializing Python:', error);
                document.getElementById('loadingSection').innerHTML = `
                    <h3 style="color: #e53e3e;">‚ùå Failed to Load Python Environment</h3>
                    <p>Error: ${error.message}</p>
                    <p>Please refresh the page to try again, or check your internet connection.</p>
                `;
            }
        }

        // File selection
        function selectFile() {
            document.getElementById('fileInput').click();
        }

        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('fileName').textContent = `Selected: ${file.name}`;
                originalDocument = file;
            }
        });

        // Process document with real DOCX support
        async function processDocument() {
            if (!originalDocument) {
                alert('Please select a document first!');
                return;
            }

            if (!pyodide) {
                alert('Python environment not ready. Please wait for initialization to complete.');
                return;
            }

            const processButton = document.getElementById('processButton');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            processButton.disabled = true;
            processButton.textContent = 'üîÑ Processing...';
            progressBar.classList.remove('hidden');
            
            try {
                // Read document as binary data
                updateProgress(10, 'Reading DOCX document...');
                const arrayBuffer = await originalDocument.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Get settings
                updateProgress(30, 'Preparing processing...');
                const targetWordCount = parseInt(document.getElementById('targetWordCount').value) || null;
                const targetReadingLevel = parseFloat(document.getElementById('targetReadingLevel').value) || 8;
                
                // Pass binary data to Python
                updateProgress(50, 'Processing with Python + python-docx...');
                pyodide.globals.set('docx_bytes', uint8Array);
                pyodide.globals.set('target_word_count', targetWordCount);
                pyodide.globals.set('target_reading_level', targetReadingLevel);
                
                const results = pyodide.runPython(`
                    result = process_docx_document(docx_bytes.tobytes(), target_word_count, target_reading_level)
                    result
                `);
                
                updateProgress(80, 'Generating reports...');
                
                // Convert Python dict to JavaScript object
                analysisResults = results.toJs({dict_converter: Object.fromEntries});
                analysisResults.originalFileName = originalDocument.name;
                
                // Generate analysis report DOCX
                if (!analysisResults.error) {
                    pyodide.globals.set('analysis_data', results);
                    pyodide.globals.set('original_filename', originalDocument.name);
                    
                    const reportBase64 = pyodide.runPython(`
                        create_analysis_report_docx(analysis_data.to_py(), original_filename, target_word_count, target_reading_level)
                    `);
                    
                    if (reportBase64) {
                        analysisResults.reportDocxBase64 = reportBase64;
                    }
                }
                
                updateProgress(100, 'Complete!');
                
                // Display results
                if (analysisResults.error) {
                    throw new Error(analysisResults.error);
                }
                
                displayResults();
                
            } catch (error) {
                console.error('Processing error:', error);
                alert('Error processing document: ' + error.message);
            } finally {
                processButton.disabled = false;
                processButton.textContent = 'üöÄ Process Document';
                setTimeout(() => {
                    progressBar.classList.add('hidden');
                    progressFill.style.width = '0%';
                }, 1000);
            }
        }

        // Remove the old readDocumentAsText function since we're using python-docx now

        function downloadProcessedDocument() {
            if (!analysisResults) {
                alert('No processed document available');
                return;
            }
            
            // Download the processed DOCX if available
            if (analysisResults.processedDocxBase64) {
                downloadBase64File(
                    analysisResults.processedDocxBase64,
                    `${analysisResults.originalFileName.replace('.docx', '')}_processed_${getTimestamp()}.docx`,
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                );
            } else {
                // Fallback to text version
                const content = `PROCESSED DOCUMENT
Original: ${analysisResults.originalFileName}
Processed: ${new Date().toLocaleDateString()}
Quality Score: ${analysisResults.qualityScore}/100
Total Corrections: ${analysisResults.totalCorrections}
Paragraphs Extracted: ${analysisResults.extractedParagraphs || 'N/A'}

========================================
PROCESSED CONTENT:
========================================

${analysisResults.processedText}

========================================
CORRECTIONS SUMMARY:
========================================

${Object.entries(analysisResults.correctionsByCategory)
    .map(([category, count]) => `${category}: ${count} corrections`)
    .join('\n')}
`;
                
                openDownloadWindow('Processed Document', content);
            }
        }

        function downloadReport() {
            if (!analysisResults) {
                alert('No analysis results available');
                return;
            }
            
            // Download the DOCX report if available
            if (analysisResults.reportDocxBase64) {
                downloadBase64File(
                    analysisResults.reportDocxBase64,
                    `Document_Analysis_Report_${getTimestamp()}.docx`,
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                );
            } else {
                // Fallback to text report
                const report = generateTextReport();
                openDownloadWindow('Document Analysis Report', report);
            }
        }

        function downloadBase64File(base64Data, filename, mimeType) {
            try {
                // Convert base64 to blob
                const byteCharacters = atob(base64Data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: mimeType });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                console.log(`Downloaded: ${filename}`);
                
                // Show success feedback
                showDownloadSuccess(filename);
                
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            }
        }

        function showDownloadSuccess(filename) {
            // Create temporary success message
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #48bb78;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                font-weight: 600;
            `;
            successDiv.textContent = `‚úÖ Downloaded: ${filename}`;
            
            document.body.appendChild(successDiv);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (document.body.contains(successDiv)) {
                    document.body.removeChild(successDiv);
                }
            }, 3000);
        }

        function getTimestamp() {
            return new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        }

        function updateProgress(percentage, message) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('processButton').textContent = `üîÑ ${message}`;
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.remove('hidden');
            
            // Update statistics
            document.getElementById('totalCorrections').textContent = analysisResults.totalCorrections;
            document.getElementById('wordCount').textContent = analysisResults.statistics.wordCount.toLocaleString();
            document.getElementById('readingLevel').textContent = `Grade ${analysisResults.statistics.readingLevel}`;
            document.getElementById('qualityScore').textContent = `${analysisResults.qualityScore}/100`;
            
            // Display quality score with color coding
            const qualityScoreDisplay = document.getElementById('qualityScoreDisplay');
            const score = analysisResults.qualityScore;
            let scoreClass, scoreText;
            
            if (score >= 90) {
                scoreClass = 'score-excellent';
                scoreText = 'Excellent Quality';
            } else if (score >= 75) {
                scoreClass = 'score-good';
                scoreText = 'Good Quality';
            } else if (score >= 60) {
                scoreClass = 'score-fair';
                scoreText = 'Fair Quality';
            } else {
                scoreClass = 'score-poor';
                scoreText = 'Needs Improvement';
            }
            
            qualityScoreDisplay.innerHTML = `
                <div class="quality-score ${scoreClass}">
                    ${score}/100 - ${scoreText}
                </div>
            `;
            
            // Display corrections
            const correctionsList = document.getElementById('correctionsList');
            correctionsList.innerHTML = '';
            
            if (analysisResults.corrections.length === 0) {
                correctionsList.innerHTML = '<div style="text-align: center; color: #48bb78; font-weight: 600;">No corrections needed - document already meets standards!</div>';
            } else {
                // Group corrections by category
                const groupedCorrections = {};
                analysisResults.corrections.forEach(correction => {
                    if (!groupedCorrections[correction.category]) {
                        groupedCorrections[correction.category] = [];
                    }
                    groupedCorrections[correction.category].push(correction);
                });
                
                // Display corrections by category
                Object.entries(groupedCorrections).forEach(([category, corrections]) => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.innerHTML = `
                        <h5 style="color: #48bb78; margin: 15px 0 10px 0; text-transform: capitalize;">
                            ${category.replace(/([A-Z])/g, ' $1').trim()} (${corrections.length})
                        </h5>
                    `;
                    correctionsList.appendChild(categoryDiv);
                    
                    corrections.slice(0, 5).forEach(correction => { // Show max 5 per category
                        const correctionDiv = document.createElement('div');
                        correctionDiv.className = 'correction-item';
                        correctionDiv.innerHTML = `
                            <div><strong>${correction.rule}</strong></div>
                            <div>
                                <span class="original-text">"${correction.original}"</span> ‚Üí 
                                <span class="corrected-text">"${correction.replacement}"</span>
                            </div>
                        `;
                        correctionsList.appendChild(correctionDiv);
                    });
                    
                    if (corrections.length > 5) {
                        const moreDiv = document.createElement('div');
                        moreDiv.style.fontStyle = 'italic';
                        moreDiv.style.color = '#718096';
                        moreDiv.style.padding = '10px';
                        moreDiv.textContent = `... and ${corrections.length - 5} more corrections in this category`;
                        correctionsList.appendChild(moreDiv);
                    }
                });
            }
            
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function downloadProcessedDocument() {
            if (!analysisResults) {
                alert('No processed document available');
                return;
            }
            
            // Download the processed DOCX if available
            if (analysisResults.processedDocxBase64) {
                downloadBase64File(
                    analysisResults.processedDocxBase64,
                    `${analysisResults.originalFileName.replace('.docx', '')}_processed_${getTimestamp()}.docx`,
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                );
            } else {
                // Fallback to text version
                const content = `PROCESSED DOCUMENT
Original: ${analysisResults.originalFileName}
Processed: ${new Date().toLocaleDateString()}
Quality Score: ${analysisResults.qualityScore}/100
Total Corrections: ${analysisResults.totalCorrections}
Paragraphs Extracted: ${analysisResults.extractedParagraphs || 'N/A'}

========================================
PROCESSED CONTENT:
========================================

${analysisResults.processedText}

========================================
CORRECTIONS SUMMARY:
========================================

${Object.entries(analysisResults.correctionsByCategory)
    .map(([category, count]) => `${category}: ${count} corrections`)
    .join('\n')}
`;
                
                openDownloadWindow('Processed Document', content);
            }
        }

        function downloadReport() {
            if (!analysisResults) {
                alert('No analysis results available');
                return;
            }
            
            // Download the DOCX report if available
            if (analysisResults.reportDocxBase64) {
                downloadBase64File(
                    analysisResults.reportDocxBase64,
                    `Document_Analysis_Report_${getTimestamp()}.docx`,
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                );
            } else {
                // Fallback to text report
                const report = generateTextReport();
                openDownloadWindow('Document Analysis Report', report);
            }
        }

        function openDownloadWindow(title, content) {
            const newWindow = window.open('', '_blank');
            newWindow.document.write(`
                <html>
                    <head>
                        <title>${title}</title>
                        <style>
                            body { font-family: monospace; padding: 20px; background: #f5f5f5; }
                            .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 1000px; margin: 0 auto; }
                            .header { background: #48bb78; color: white; padding: 15px; margin: -30px -30px 20px -30px; border-radius: 8px 8px 0 0; }
                            .button { background: #48bb78; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 10px 5px; }
                            .button:hover { background: #38a169; }
                            pre { white-space: pre-wrap; line-height: 1.5; background: #f8f9fa; padding: 20px; border-radius: 5px; border-left: 4px solid #48bb78; }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <div class="header">
                                <h2>üìÑ ${title}</h2>
                                <p>Copy the content below and save as a text file</p>
                            </div>
                            <button class="button" onclick="selectAll()">üìã Select All</button>
                            <button class="button" onclick="copyToClipboard()">üìÑ Copy to Clipboard</button>
                            <button class="button" onclick="window.print()">üñ®Ô∏è Print</button>
                            <hr style="margin: 20px 0;">
                            <pre id="content">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                        </div>
                        <script>
                            function selectAll() {
                                const content = document.getElementById('content');
                                const range = document.createRange();
                                range.selectNode(content);
                                window.getSelection().removeAllRanges();
                                window.getSelection().addRange(range);
                            }
                            
                            function copyToClipboard() {
                                const content = document.getElementById('content').textContent;
                                navigator.clipboard.writeText(content).then(function() {
                                    alert('Content copied to clipboard!');
                                }, function() {
                                    selectAll();
                                    alert('Please copy the selected text manually (Ctrl+C)');
                                });
                            }
                            
                            window.onload = function() { selectAll(); }
                        </script>
                    </body>
                </html>
            `);
            newWindow.document.close();
        }

        function generateTextReport() {
            const date = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            let report = `DOCUMENT PROCESSING REPORT
Generated: ${date}
Document: ${analysisResults.originalFileName}

==============================================
EXECUTIVE SUMMARY
==============================================
Quality Score: ${analysisResults.qualityScore}/100
Total Corrections: ${analysisResults.totalCorrections}
Word Count: ${analysisResults.statistics.wordCount.toLocaleString()}
Reading Level: Grade ${analysisResults.statistics.readingLevel}
Sentences: ${analysisResults.statistics.sentenceCount}
Paragraphs: ${analysisResults.statistics.paragraphCount}

==============================================
DOCUMENT STATISTICS
==============================================
Average Words per Sentence: ${analysisResults.statistics.avgWordsPerSentence}
Average Syllables per Word: ${analysisResults.statistics.avgSyllablesPerWord}

Target Analysis:
`;

            const targetWordCount = parseInt(document.getElementById('targetWordCount').value);
            const targetReadingLevel = parseFloat(document.getElementById('targetReadingLevel').value);
            
            if (targetWordCount) {
                const difference = analysisResults.statistics.wordCount - targetWordCount;
                const status = Math.abs(difference) <= (targetWordCount * 0.1) ? '‚úì On Target' : 
                              difference > 0 ? `‚ö† Over by ${difference.toLocaleString()} words` : 
                              `‚ö† Under by ${Math.abs(difference).toLocaleString()} words`;
                report += `Word Count Target: ${analysisResults.statistics.wordCount.toLocaleString()} (target: ${targetWordCount.toLocaleString()}) ${status}\n`;
            }
            
            const levelDiff = analysisResults.statistics.readingLevel - targetReadingLevel;
            const levelStatus = Math.abs(levelDiff) <= 1 ? '‚úì Appropriate Level' : 
                               `‚ö† Difference: ${levelDiff > 0 ? '+' : ''}${levelDiff.toFixed(1)} grades`;
            report += `Reading Level: Grade ${analysisResults.statistics.readingLevel} (target: Grade ${targetReadingLevel}) ${levelStatus}\n`;

            report += `
==============================================
EDITING STANDARDS APPLIED
==============================================
Total Corrections: ${analysisResults.totalCorrections}

Corrections by Category:
`;

            Object.entries(analysisResults.correctionsByCategory)
                .sort(([,a], [,b]) => b - a)
                .forEach(([category, count]) => {
                    const categoryName = category.replace(/([A-Z])/g, ' $1').trim();
                    report += `‚Ä¢ ${categoryName}: ${count} corrections\n`;
                });

            if (analysisResults.corrections.length > 0) {
                report += `\nSample Corrections Applied:\n`;
                analysisResults.corrections.slice(0, 10).forEach((correction, index) => {
                    report += `${index + 1}. ${correction.rule}\n`;
                    report += `   "${correction.original}" ‚Üí "${correction.replacement}"\n\n`;
                });
                
                if (analysisResults.corrections.length > 10) {
                    report += `... and ${analysisResults.corrections.length - 10} more corrections\n`;
                }
            }

            report += `
==============================================
RECOMMENDATIONS
==============================================
`;

            if (analysisResults.qualityScore >= 90) {
                report += "1. Excellent quality - document meets professional standards\n";
            } else if (analysisResults.qualityScore >= 75) {
                report += "1. Good quality - minor improvements may be beneficial\n";
            } else {
                report += "1. Consider additional review for quality improvements\n";
            }

            if (analysisResults.totalCorrections > 50) {
                report += `2. Applied ${analysisResults.totalCorrections} professional editing standards - document now compliant\n`;
            } else if (analysisResults.totalCorrections > 0) {
                report += `2. Applied ${analysisResults.totalCorrections} corrections to improve compliance\n`;
            } else {
                report += "2. Document already met professional editing standards\n";
            }

            if (analysisResults.statistics.readingLevel > 10) {
                report += "3. Consider simplifying language to improve readability\n";
            } else if (analysisResults.statistics.readingLevel < 6) {
                report += "3. Content may be too simple for target audience\n";
            }

            report += `\n==============================================
PROCESSING COMPLETE
Generated by Document Processor (Python-Powered)
Professional document editing and quality analysis
==============================================`;

            return report;
        }

        // Initialize when page loads
        window.addEventListener('load', initializePython);
    </script>
</body>
</html>
        